---
title: "15. Visualising Data"
output:
  html_document:
    includes:
      in_header: header.html    
    toc: true
    toc_float: true
    theme: flatly
    highlight: textmate
    css: mystyle.css
    number_sections: true
    pandoc_args: [
      "--number-offset", 15
    ]
---

```{r,echo=FALSE, message=FALSE, warning=FALSE}
rm(list=objects()) # start with a clean workspace
source("knitr_tweaks.R")
library(tidyverse,quietly = TRUE)
```

> Above all else show the data. <br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--Edward Tufte, *The Visual Display of Quantitative Information*, 2001


Visualising data is one of the most important tasks facing the data analyst. It’s important for two distinct but closely related reasons. Firstly, there’s the matter of drawing “presentation graphics”: displaying your data in a clean, visually appealing fashion makes it easier for your reader to understand what you’re trying to tell them. Equally important, perhaps even more important, is the fact that drawing graphs helps you to understand the data. To that end, it’s important to draw “exploratory graphics” that help you learn about the data as you go about analysing it. These points might seem pretty obvious, but I cannot count the number of times I’ve seen people forget them.

To give a sense of the importance of this chapter, I want to start with a classic illustration of just how powerful a good graph can be. To that end, the figure below shows a redrawing of one of the most famous data visualisations of all time (courtesy of Michael Friendly's `HistData` package): John Snow’s 1854 map of cholera deaths. The map is elegant in its simplicity. In the background we have a street map, which helps orient the viewer. Over the top, we see a large number of small dots, each one representing the location of a cholera case. The larger symbols show the location of water pumps, labelled by name. Even the most casual inspection of the graph makes it very clear that the source of the outbreak is almost certainly the Broad Street pump. Upon viewing this graph, Dr Snow arranged to have the handle removed from the pump, ending the outbreak that had killed over 500 people. Such is the power of a good data visualisation.

```{r, echo=FALSE}
library(HistData)

# make sure data are loaded into the calling environment
# in the chunk not the .GlobalEnv from which I call psyr_render
data(Snow.deaths, envir = parent.frame())
data(Snow.pumps, envir = parent.frame())
data(Snow.streets, envir = parent.frame())
data(Snow.polygons, envir = parent.frame())

## draw a rough approximation to Snow's map and data

# define some funtions to make the pieces re-usable
Sdeaths <- function(col="orange", pch=15, cex=0.6, points = TRUE, title = NULL) {
  # make sure that the plot limits include all the other stuff
  par(mar = c(1,1,4,1)+.1)
  plot.new();
  plot.window(xlim=c(3,20), ylim=c(3,20))
  if(points){
    lines(Snow.deaths[,c("x","y")], col=col, pch=pch, cex=cex, type = "p")
  }
  if(is.null(title)) { title <- "Snow's cholera map of London"}
  title(
    xlab="", ylab="",  
    main=title,font.main = 1)
}

# function to plot and label the pump locations
Spumps <- function(col="blue", pch=1, cex=1.5, label = TRUE)  {
  points(Snow.pumps[,c("x","y")], col=col, pch=pch, cex=cex, lwd = 2)
  if(label){
    text(Snow.pumps[,c("x","y")], labels=Snow.pumps$label, pos=1, cex=0.8)
  }
}

# function to draw the streets 
Sstreets <- function(col="gray") {
  slist <- split(Snow.streets[,c("x","y")],as.factor(Snow.streets[,"street"]))
  invisible(lapply(slist, lines, col=col))
}

# draw a scale showing distance in meters in upper left
mapscale <- function(xs=3.5, ys=19.7) {
  scale <- matrix(c(0,0, 4,0, NA, NA), nrow=3, ncol=2, byrow=TRUE)
  colnames(scale)<- c("x","y")
  
  # tick marks
  scale <- rbind(scale, expand.grid(y=c(-.1, .1, NA), x=0:4)[,2:1])
  lines(xs+scale[,1], ys+scale[,2])
  
  # value and axis labels
  stext <- matrix(c(0,0, 2,0, 4,0, 4, 0.1), nrow=4, ncol=2, byrow=TRUE)
  text(xs+stext[,1], ys+stext[,2], labels=c("0", "2", "4", "100 m."), pos=c(1,1,1,4), cex=0.8)
}


##### PLOT 1 #####

Sdeaths()
Spumps()
Sstreets()
mapscale()
```


The goals in this chapter are twofold: firstly, to discuss several fairly standard graphs that we use a lot when analysing and presenting data, and secondly, to show you how to create graphs in R. 

With that in mind, the structure of this chapter is as follows: I’ll start out by giving you a very quick overview of how graphics work in R. I’ll then discuss several different kinds of graph and how to draw them, as well as showing the basics of how to customise these plots. I’ll then talk in more detail about R graphics, discussing some of those complicated and boring issues. 

## R graphics

Reduced to its simplest form, you can think of R graphics like a painting. You start out with an empty canvas. Every time you use a graphics function, it paints some new things onto your canvas. Later you can paint more things over the top if you want, layering new information over the old. This way of thinking about plotting data is referred to as the **painter’s model** - the key thing to keep in mind is because the plot is constructed sequentially, the order in which you do things matters. 

We can extend the painting metaphor a little. If you want to paint a picture, you need to paint it on something. In real life, you can paint on lots of different things. Painting onto canvas isn’t the same as painting onto paper, and neither  is the same as painting on a wall. In R, the thing that you paint onto is called a **graphics device**. In RStudio, the default graphics device is `RStudioGD` and it corresponds to the "plot" pane. If you were using the basic R program for Windows (i.e., `R.exe`) the default device is `windows`, on the Mac application (`R.app`) it’s called `quartz`, etc.  However, from the computer's perspective there’s nothing terribly special about drawing pictures on screen, and so R is quite happy to paint pictures directly into a file. R can paint several different types of image files: `jpeg`, `png`, `pdf`, `postscript`, `tiff` and `bmp` files are all available as graphics devices and you can write plots directly to those using those^[If you are interested, take a look at the various `dev` functions for working with graphics devces, such as `dev.new`, `dev.print`, `dev.off` etc. I won't talk about those here because I'm focusing on **tidyverse** but they're handy in other situations]

Secondly, when you paint a picture you need to paint it with something. Maybe you want to do an oil painting, but maybe you want to use watercolour. And, generally speaking, you pretty much have to pick one or the other. The analog to this in R is a “graphics system”. A graphics system defines a collection of graphics commands about what to draw and where to draw it. Something that surprises most new R users is the discovery that R actually has several mutually incompatible graphics systems. The two of most interest to us are the **base graphics** system that comes with R and the **ggplot2** system^[It's worth acknowledging that **ggplot2** and builds off the **grid** graphics system that we very briefly encountered when using **TurtleGraphics**] that forms part of **tidyverse**. There's quite a difference of opinion among R users about the relative merits of these two systems. You can get started in base graphics really easily. To see just how easy it is, let's load a new data set and try to draw a picture. The [frames](./data/frames_ex2.csv) data set comes from a simple experiment I ran a little while ago, and over the course of this section I'll try to explain what the experiment was all about, using data visualisations drawn using R to tell the story. Here's the data

```{r,message=FALSE}
frames <- read_csv("./data/frames_ex2.csv")
frames
```

Using the tools from the last section, let's also create a smaller summary data frame that contains one row per person:

```{r}
frames_small <- frames %>%
  group_by(id, gender, age, condition) %>%
  summarise(response = mean(response))
frames_small
```

## Histograms

Let's give ourselves the task of drawing a histogram of the `age` variable in this data frame. We don't need to make it pretty, we just want to plot the frequency distribution for the number of points scored by the home team. The function to do this in base graphics is called `hist` and here it is:
```{r}
hist(frames_small$age)
```
It's not exactly pretty -- though it's way nicer than the default plots that I remember seeing when I was younger -- but it gets the job done. 

Okay, how do I create a histogram the tidyverse way? Much like base graphics, **ggplot2** recognises that histograms are such a fundamentally useful thing that there exists a "geom" (a term I'll explain in a moment) for them, but there's no way to draw a plot without going through a somewhat more convoluted process:
```{r,message=FALSE}
frames_small %>%
  ggplot(aes(x = age)) +
  geom_histogram()
```
The output is prettier, admittedly, but our goal here wasn't to be pretty. Our goal was to be simple. For this comparison, the tidyverse approach is not as straightforward as base graphics.

Where the tidyverse versions shines is when we want to do something a little bit more complicated. Suppose I wanted two histograms side by side, plotting the age distribution separately by `condition`. In base graphics, it's a little cumbersome. What I have to do here is manually control the "layout" of the plot, dividing it into two separate panels and then drawing the histogram separately into each panel. That gives me code that looks like this:

```{r,results='hold'}
layout(matrix(1:2, 1, 2))
hist(frames_small$age[frames$condition == "category"])
hist(frames_small$age[frames$condition == "property"])
```

I need a lot more code as I did for the original version and I've ended up with a pretty ugly plot -- base graphics absolutely does allow me to do a much better job than this, but clearly it's going to take a lot of effort to make this nice. 

In contrast, using **ggplot2** to do the work all I need is one extra line, and the result is actually kind of nice:

```{r,message=FALSE}
frames_small %>%
  ggplot(aes(x = age)) +
  geom_histogram() +
  facet_wrap(~condition)
```

For me at least, this is the big advantage to the **ggplot2** approach. There's a certain amount of effort required to construct the basic plot, but once that is done, you can modify or manipulate that plot in an extremely flexible fashion with very little effort indeed. What I've found in practice is that the low-effort to making changes makes me much more willing to "play around" with different ways of visualising the data. So, while I'll admit that there are some situations where I resort to using base graphics (mostly when I have a very unconventional graph to draw), I tend to find the tidyverse approach works better in the majority of cases. 

## Scatter plot

Start out by taking the data and passing it to `ggplot` without giving anything else to work with, and we get a blank canvas as the result

```{r}
frames_small %>% 
  ggplot()
```

The next step is to add some *aesthetics* so that the plot knows what we're expecting to see.

```{r}
frames_small %>% 
  ggplot(mapping = aes(x = age, y = response, group = condition))
```

Now, we need to add some *geoms*, abstract ideas about what kind of things we could plot on the canvas. Since we're trying to draw a scatter plot, I'm going to use `geom_point`

```{r}
frames_small %>% 
  ggplot(mapping = aes(x = age, y = response, colour = condition)) +
  geom_point()
```


## Bar graphs

```{r}
frames_small %>%
  ggplot(mapping = aes(x = gender)) +
  geom_bar() + 
  facet_wrap(~condition)
```

## Box plots

```{r}
frames_small %>%
  ggplot(aes(x = condition, y = response)) + 
  geom_boxplot()
```

## Violin plots

```{r}
frames_small %>%
  ggplot(aes(x = condition, y = response)) + 
  geom_violin()
```


## Facetting

```{r}
frames %>%
  ggplot(aes(x = factor(test_item), y = response)) + 
  geom_boxplot() +
  facet_grid(sample_size ~ condition)
```


## Counts


```{r}
frames %>%
  ggplot(aes(x = test_item, y = response)) + 
  geom_count() +
  facet_grid(sample_size ~ condition)
```


## Line graphs

The box plots here are a little busy. Let's simplify this by plotting the mean response

```{r, fig.width=6, fig.height=4}
frames_cond <- frames %>%
  group_by(condition,sample_size,test_item) %>%
  summarise(
    mean_response = mean(response),
    lower = lsr::ciMean(response)[1],
    upper = lsr::ciMean(response)[2]
  )
frames_cond

frames_cond %>%
  ggplot(aes(x=test_item,y=mean_response,colour=condition)) +
  geom_point() +
  geom_line() +
  facet_wrap(~ sample_size)
```


## Reordering facets

```{r, fig.width=6, fig.height=4}
frames_cond <- frames_cond %>% 
  ungroup() %>%
  mutate(
    sample_size = factor(
      x = sample_size,
      levels = c("small", "medium", "large")
    )
  )

my_pic <- frames_cond %>%
  ggplot(aes(x=test_item,y=mean_response,colour=condition)) +
  geom_point() +
  geom_line() +
  facet_wrap(~ sample_size)
```

Now when we plot this:

```{r}
plot(my_pic)
```

## Saving images

```{r}
ggsave(
  filename = "./output/frame_pic.png",
  plot = my_pic,
  width = 16,
  height = 8,
  units = "cm"
)
```

That creates [this image file](./output/frame_pic.png).

## Adding error bars

```{r}
my_pic + 
  geom_errorbar(aes(ymin=lower, ymax=upper))
```


## Contour plots

```{r, fig.width=6, fig.height=4}
frames_small %>% 
  ggplot(mapping = aes(x = age, y = response, colour = condition)) +
  geom_point() + 
  theme_bw() +
  geom_density_2d() +
  facet_wrap(~condition) +
  ylim(0,9)
```

## Smoothing

```{r}
frames_small %>% 
  ggplot(mapping = aes(x = age, y = response, colour = condition)) +
  geom_point() + 
  geom_smooth(method = "lm") +
  facet_wrap(~condition) +
  ylim(0,9)
```


## Customising

Plots are remarkably customisable. We could switch to a dark theme and customise the axis labels with this command...

```{r, fig.width=6, fig.height=4}
my_pic + 
  theme_dark() +
  scale_color_brewer(palette = "Pastel2") +
  ylim(0, 9) + 
  geom_vline(xintercept = 2.5, colour = "white", lty = "dotted") +
  xlab("Location of Test Stimulus") +
  ylab("Mean Response")
```



     