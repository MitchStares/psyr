---
title: "Probability Distributions"
output:
  html_document:
    includes:
      in_header: header.html    
    toc: true
    toc_float: true
    theme: flatly
    highlight: textmate
    css: mystyle.css
    number_sections: true
    pandoc_args: [
      "--number-offset", 0
    ]
---

```{r,echo=FALSE,message=FALSE,warning=FALSE}
rm(list=objects()) # start with a clean workspace
source("knitr_tweaks.R")
library(lsr,quietly = TRUE)
library(tidyverse,quietly = TRUE)
```


## Prelude

R is very often described as a *statistical programming environment*, because - while it does get used for an incredible variety of purposes - it began its life as a tool for helping statisticians analyse data. As such, it has an unrivalled collection of statistical packages built into it, and I'll talk a little about some of them later. However, before starting to talk about statistics, it's very useful to talk about *probability distributions* and how they are usually implemented in R.

Speaking of which, what exactly is the difference between probability theory and statistics? The two disciplines are closely related but they’re not identical. Probability theory is “the doctrine of chances”. It’s a branch of mathematics that tells you how often different kinds of events will happen. For example, all of these questions are things you can answer using probability theory:

- What are the chances of a fair coin coming up heads 10 times in a row?
- If I roll two six sided dice, how likely is it that I’ll roll two sixes?
- How likely is it that five cards drawn from a perfectly shuffled deck will all be hearts?
- What are the chances that I’ll win the lottery?

Notice that all of these questions have something in common. In each case the “truth of the world” is known, and my question relates to the “what kind of events” will happen. In the first question I *know* that the coin is fair, so there’s a 50% chance that any individual coin flip will come up heads. In the second question, I *know* that the chance of rolling a 6 on a single die is 1 in 6. In the third question I *know* that the deck is shuffled properly. And in the fourth question, I *know* that the lottery follows specific rules. You get the idea. The critical point is that probabilistic questions start with a known **model** of the world, and we use that model to do some calculations. The underlying model can be quite simple. For instance, in the coin flipping example, we can write down the model like this:
$$
P(\mbox{heads}) = 0.5
$$
which you can read as “the probability of heads is 0.5”. As we’ll see later, in the same way that percentages are numbers that range from 0% to 100%, probabilities are just numbers that range from 0 to 1. When using this probability model to answer the first question, I don’t actually know exactly what’s going to happen. Maybe I’ll get 10 heads, like the question says. But maybe I’ll get three heads. That’s the key thing: in probability theory, *the model is known, but the data are not.*

So that’s probability. What about statistics? Statistical questions work the other way around. In statistics, we do not know the truth about the world. All we have is the data, and it is from the data that we want to learn the truth about the world. Statistical questions tend to look more like these:

- If my friend flips a coin 10 times and gets 10 heads, are they playing a trick on me?
- If five cards off the top of the deck are all hearts, how likely is it that the deck was shuffled?
- If the lottery commissioner’s spouse wins the lottery, how likely is it that the lottery was rigged?

This time around, *the only thing we have are data*. What I know is that I saw my friend flip the coin 10 times and it came up heads every time. And what I want to **infer** is whether or not I should conclude that what I just saw was actually a fair coin being flipped 10 times in a row, or whether I should suspect that my friend is playing a trick on me. The data I have look like this:
$$
HHHHHHHHHHH
$$
and what I’m trying to do is work out which “model of the world” I should put my trust in. If the coin is fair, then the model I should adopt is one that says that the probability of heads is 0.5; that is, $P(\mbox{heads} = 0.5$. If the coin is not fair, then I should conclude that the probability of heads is not 0.5, which we would write as $P(\mbox{heads} \neq 0.5$. In other words, the statistical inference problem is to figure out which of these probability models is right. Clearly, the statistical question isn’t the same as the probability question, but they’re deeply connected to one another. Because of this, a good introduction to statistical theory will start with a discussion of what probability is and how it works.

### What does probability mean?

Let’s start with the first of these questions. What is “probability”? It might seem surprising to you, but while statisticians and mathematicians (mostly) agree on what the rules of probability are, there’s much less of a consensus on what the word really means. It seems weird because we’re all very comfortable using words like “chance”, “likely”, “possible” and “probable”, and it doesn’t seem like it should be a very difficult question to answer. If you had to explain “probability” to a five year old, you could do a pretty good job. But if you’ve ever had that experience in real life, you might walk away from the conversation feeling like you didn’t quite get it right, and that (like many everyday concepts) it turns out that you don’t really know what it’s all about. In the statistic literature there are two qualitatively different ideas about how to define the term:

- The **frequentist view ** defines probability as *long-run frequency*. Suppose we were to try flipping a fair coin, over and over again, and divide the number of heads $n_h$ by the total number of coin flips $n$, yielding $p_h = n_h/n$ as the observed proportion. The frequentists argue that the only way to meaningfully define the idea of probability is in terms of what happens to this empirically observed proportion a the sample size becomes arbitrarily large (i.e., $n \rightarrow \infty$). In the long run, the proportion of heads will eventually converge to 50%. There are some subtle technicalities that the mathematicians care about, but qualitatively speaking, that’s how the frequentists define probability. Probability is a "thing in the world"
- The **Bayesian view**  is often called the subjectivist view, and it is a minority view among statisticians, but one that has been steadily gaining traction for the last several decades. There are many flavours of Bayesianism, making hard to say exactly what “the” Bayesian view is. The most common way of thinking about subjective probability is to define the probability of an event as the *degree of belief* that an intelligent and rational agent assigns to that truth of that event. From that perspective, probabilities don’t exist in the world, but rather in the thoughts and assumptions of people and other intelligent beings. However, in order for this approach to work, we need some way of operationalising “degree of belief”. One way that you can do this is to formalise it in terms of “rational gambling”, though there are many other ways. Suppose that I believe that there’s a 60% probability of rain tomorrow. If someone offers me a bet: if it rains tomorrow, then I win \$5, but if it doesn’t rain then I lose \$5. Clearly, from my perspective, this is a pretty good bet. On the other hand, if I think that the probability of rain is only 40%, then it’s a bad bet to take. Thus, we can operationalise the notion of a “subjective probability” in terms of what bets I’m willing to accept. Probability, from this perspective, is a "thing in the head".

My personal view is much closer to the Bayesian perspective, and I tend to use Bayesian methods myself, but I'll talk a bit about both approaches in this book. Regardless of which version you prefer, the core *mechanics* for working with probabilities in R are the same.

## Sampling from a set

The `sample()` function is an extremely useful tool. Suppose I have a set of 10 stimuli that I want to present to people in a random order. For simplicity I'll label the items using `letters`:^[The `letters` vector is a built in vector in R that contains the 26 lower case letters of the English alphabet in canonical order. There is also a `LETTERS` vector that has the upper case letters.]

```{r}
stimuli <- letters[1:10]
stimuli
```

To sample them in a random order, all I need to do is this

```{r}
shuffled_stimuli <- sample(stimuli)
shuffled_stimuli
```

Or to do the same thing with piped code...

```{r}
shuffled_stimuli <- stimuli %>% sample()
shuffled_stimuli
```

Notice that the output the second time around *isn't* the same a the output the first time. The `sample()` function uses a pseudo-random number generator to order the items differently every time.

```{r}
for(i in 1:5) {
  stimuli %>%
    sample() %>%
    print()
}
```

As you can see if you feed in a vector of inputs, the default behaviour is to shuffle all the items. However, the `sample()` function is flexible. For example, "shuffling all the items" is a special case of "sampling without replacement". Imagine taking all the stimuli (*letters*), and then placing them into a jar. To shuffle them into a random order all you need to do is shake the jar (*randomise*) pull them out of the jar (*sample*) one at a time until the jar is empty (*no replacement*).

The jars metaphor is nice because we can extend it. Suppose we only want to pull 6 of the 10 stimuli out of the jar:

```{r}
stimuli %>% sample(size = 6)
```

Again, there are no repeats (it is impossible to pull the same item from the jar twice), but we stopped before pulling everything out. Here's a loop showing you how the randomisation gives different answers every time, but it always follows the constraints of stopping at 6 draws and never draws the same item twice:

```{r}
for(i in 1:5) {
  stimuli %>%
    sample(size = 6) %>%
    print()
}
```

Another way to extend the jars metaphor is to sample *with replacement*. In this version of the sampling scheme, every time we pull a letter out of the jar we write it down, but then put it back in the jar so that it becomes possible to sample it again.

```{r}
for(i in 1:5) {
  stimuli %>%
    sample(size = 15, replace = TRUE) %>%
    print()
}
```

Notice that this time you can produce sequences of stimuli that are longer than the original set (because you're putting them back in the jar). In this case even though I only had 10 items, each output has 15 samples from that set: there are of course repeats!

A final way we can extend the metaphor is to imagine that some of the letters are written on larger pieces of paper than others: so when you reach into the hat you're more likely to pull out the larger ones.

```{r}
weights <- 1:10 # weight the later letters more!
```

You can use this when sampling with replacement and without. Here's what it looks like when sampling without replacement:

```{r}
for(i in 1:5) {
  stimuli %>%
    sample(size = 10, replace = FALSE, prob = weights) %>%
    print()
}
```

So in this output every line shuffles the 10 items, but there's a definite bias in how the items are ordered! We're much more likely to start with the later letters than with the early ones!

We can also do this when sampling with replacement:


```{r}
for(i in 1:5) {
  stimuli %>%
    sample(size = 10, replace = TRUE, prob = weights) %>%
    print()
}
```

In this output, you can see that we're very unlikely to sample the letter "a".


## Binomial distribution

The `sample()` function gives you a good feel for how you can take a set of entities (stimuli, participants, outcomes, etc) and do probabilistic operations with them. When doing statistics we sometimes like to abstract away from the simple sampling mechanism and start talking in terms of *probability distriubutions*. To see how the abstraction works let's introduce one of the simplest examples, the **binomial distriubtion**. Imagine we have a six sided die, in which four sides are coloured `"blue"` and two sides are coloured `"red"`. Let's roll the die 20 times and see what we get:

```{r}
die <- c("blue","blue","blue","blue","red","red")
rolls <- sample(die, size = 20, replace = TRUE)
rolls
```

We can count the number of times the result was `"blue"`:

```{r}
n_blue <- sum(rolls == "blue")
n_blue
```

Of course, there's nothing stopping us from repeating this exercise several times:

```{r}
for(i in 1:5){
  rolls <- die %>% sample(size = 20, replace = TRUE)
  n_blue <- sum(rolls == "blue")
  print(n_blue)
}
```

In fact, let's go all out on this. Let's replicate this tiny  experiment 100,000 times because that's easy to do with R:

```{r, cache=TRUE}
n_replications <- 100000
n_blue <- numeric(length = n_replications)
for(r in 1:n_replications){
  rolls <- die %>% sample(size = 20, replace = TRUE)
  n_blue[r] <- sum(rolls == "blue")
}
n_blue <- factor(n_blue, levels = 0:20, ordered = TRUE)
frequencies <- table(n_blue)
frequencies
```

With this particular `die` the probability of observing a `"blue"` on any one roll is two-thirds (4 out of 6 sides) and not surprisingly the outcomes of this "roll the die 20 times" experiment tend to be *distributed* mostly between 12 and 15. I hate looking at tables of numbers, so let's draw a picture:

```{r}
as_tibble(frequencies, n = "count") %>%
  mutate(n_blue = as.numeric(n_blue)) %>%
  ggplot(aes(x=n_blue, y = count)) +
  geom_col(width = .5) +
  theme_bw()
```

This picture is essentially a visualisation of the **binomial distribution** with success probability `prob = 2/3`, so it's worth taking a moment to be explicit about what we've done. Every one of our experiments produces an *outcome* (number of blues) that can be described as *one* random draw from the binomial distribution. So the 100000 replications of the experiment can be vieweed as a set of 100000 numbers sampled from the binomial. R contains a function `rbinom()` that we can use to do this directly:

```{r}
n_blue <- rbinom(n = 100000, size = 20, prob = 2/3)
```

If we process this set of numbers using the same code, we get an almost identical figure. In fact, because I'm going to reuse this code, let's write a function:

```{r}
plot_samples <- function(x, size = 20) {
  x <- factor(x, levels = 0:size)
  frequencies <- table(x)
  proportion <- frequencies / sum(frequencies)
  pic <- as_tibble(proportion, n = "proportion") %>%
    mutate(x = as.numeric(x)) %>%
    ggplot(aes(x=x, y = proportion)) +
    geom_col(width = .5) +
    xlab("outcome value") +
    ggtitle(sum(frequencies)) +
    ylim(0,.3) +
    theme_bw()
  return(pic)
}
```

Now call it:

```{r}
pic <- plot_samples(n_blue)
plot(pic)
```

Of course, the only reason it looks this nice and smooth is that we replicated the experiment 100000 times. Let's modify the code so the we start out with a relatively small number of replications and watch it smooth out as it gets larger:

```{r, binomial_samples, fig.show='animate', interval=0.1, cache=TRUE, message=FALSE}
for(rep in seq(from = 50, to = 10000, by = 50)){
  n_blue <- rbinom(n = rep, size = 20, prob = 2/3)
  pic <- plot_samples(n_blue)
  plot(pic)
}
```


If you were typing this at the console, this loop would produce a sequence of plots, but what I've done (using some clever features of R Markdown) is wrap it up as an animation. Later on I'll talk about how to make animations.

A natural question to ask is about the true probility of obtaining each outcome. One way to do it (approximately) would be to generate very large number of samples and then calculate the proportion of times that we end up with (say) 12 out of 20 rolls being blue. However, there's an easier way. There's actually a fairly simple formula for this, and R implements it using the `dbinom()` function:

```{r}
outcome_value <- 0:20
true_prob <- dbinom(x = outcome_value, size = 20, prob = 2/3)
true_prob
```

Or, since we like pictures so much...

```{r}
tibble(outcome_value, true_prob) %>%
  ggplot(aes(x = outcome_value, y = true_prob)) +
  geom_col(width = .5) +
  theme_bw()
```

Cool.

The animation below shows how the binomial distribution changes as we shift the value of `prob`:

```{r binomial, fig.show='animate', interval=0.1, cache=TRUE, message=FALSE, echo=FALSE}
xmin <- 0
xmax <- 20
prob_list <- c(seq(.67,.96,.01),seq(.96,.04,-.01),seq(.04,.67,.01))

for(prob in prob_list) {
  df <- tibble(
    Value = xmin:xmax,
    Probability = dbinom(Value, size = xmax, prob = prob)
  )
  pic <- df %>% ggplot(aes(x = Value, y = Probability)) +
    geom_col(width=.5) +
    ggtitle(paste0("Success Probability = ", sprintf("%.2f",prob))) +
    theme_bw() +
    ylim(0,.5)
  plot(pic)
}
```

Here's another one that shows what happens as we change the `size` of the experiment.



```{r binomial_size, fig.show='animate', interval=0.1, cache=TRUE, message=FALSE, echo=FALSE}
xmin <- 0
xmax_list <- 1:200

for(xmax in xmax_list) {
  df <- tibble(
    Value = xmin:xmax,
    Probability = dbinom(Value, size = xmax, prob = prob)
  )
  pic <- df %>% ggplot(aes(x = Value, y = Probability)) +
    geom_col(width=.5) +
    ggtitle(paste0("Size = ", xmax)) +
    theme_bw() +
    ylim(0,.7)
  plot(pic)
}
```

You can see the central limit theorem in action here! As the `size` gets larger, the shape of the binomial distribution gets progressively closer to normal. Speaking of which...

## Normal distribution

The normal distribution is the perhaps the most widely used distribution in statistics, so I should talk about it in some detail. It's also a good moment to talk about how the tools for working with probability distributions in R are structured. As a rule, any distribution that you want to work with in R will be associated with four separate functions. If I want to work with a normal distribution, for instance, there are four different functions - `rnorm`, `dnorm`, `pnorm` and `qnorm`. If I want to work with a uniform distribution, the functions are named `runif`, `dunif`, `punif` and `qunif`. For a binomial distribution, they are `rbinom`, `dbinom`, `pbinom` and `qbinom`. The four versions are:

- The **r form** is a random number generator: you can use it to sample `n` random outcomes from the distribution.
- The **d form** computes the probability (or probability density) with which you would observe a particular number `x` if it is generated from this distribution.
- The **p form** is the cumulative distribution function. You specify a particular value `q`, and it tells you the probability of obtaining an outcome smaller than or equal to `q`.
- The **q form** calculates the quantiles of the distribution. You specify a probability value `p`, and gives you the corresponding percentile. That is, the value of the variable for which there’s a probability `p` of obtaining an outcome lower than `q`.




```{r normal_mean, fig.show='animate', interval=0.05, cache=TRUE, message=FALSE, echo=FALSE}
xmin <- -4
xmax <- 4
sigma <- 1
mu_list <- c(seq(0,4,.05), seq(4,-4,-.05), seq(-4,0,.05))

for(mu in mu_list) {
  df <- tibble(
    Value = seq(from = xmin, to = xmax, length.out = 100),
    Density = dnorm(Value, mean = mu, sd = sigma)
  )
  pic <- df %>% ggplot(aes(x = Value, y = Density)) +
    geom_area() + ggtitle(paste0("Mean = ", round(mu, digits = 1))) +
    theme_bw()
  plot(pic)
}
```




```{r normal_std, fig.show='animate', interval=0.05, cache=TRUE, message=FALSE, echo=FALSE}
xmin <- -4
xmax <- 4
mu <- 0
sigma_list <- c(seq(1,2,.01), seq(2,.5,-.01), seq(.5,1,.01))

for(sigma in sigma_list) {
  df <- tibble(
    Value = seq(from = xmin, to = xmax, length.out = 100),
    Density = dnorm(Value, mean = mu, sd = sigma)
  )
  pic <- df %>% ggplot(aes(x = Value, y = Density)) +
    geom_area() + ggtitle(paste0("Standard Deviation = ", round(sigma, digits = 1))) +
    theme_bw() + ylim(0,.8)
  plot(pic)
}
```






For example, IQ scores are roughly normally distributed, and the tests are
(supposedly) normed in such a way that the average IQ score is 100 and the standard deviation is 15. So let's use R to randomly generate a sample of `n = 50` IQ scores using the `rnorm` function.
```{r}
iq <- rnorm(n = 50, mean = 100, sd = 15)  # sample the IQ scores
hist(iq, xlab="IQ",main="")               # draw the histogram
```

You can *kind of* see the shape of the bell curve with 50 observations, but it's not super obvious. If we ratchet up the sample size to `n = 10000` data points, it becomes a lot more obvious
```{r}
iq <- rnorm(n = 10000, mean = 100, sd = 15)  # sample the IQ scores
hist(iq, xlab="IQ",main="")               # draw the histogram
```

We can draw the bell curve itself by using the `dnorm` function:
```{r}
iq <- 40:160
prob <- dnorm(x = iq, mean = 100, sd = 15)
plot(iq, prob, xlab="IQ",ylab="Density", main="", type="l")
```

The cumulative distribution function looks like this:
```{r}
iq <- 40:160
cprob <- pnorm(q = iq, mean = 100, sd = 15)
plot(iq, cprob, xlab="IQ",ylab="Cumulative Probability", main="", type="l")
```

The quantile function is just the inverse of the cumulative distribution (i.e., x and y axes are swapped):
```{r}
prob <- seq(from = .01, to = .99, by = .01)
q <- qnorm(p = prob, mean = 100, sd = 15)
plot(prob, q, xlab="Probability",ylab="Quantile", main="", type="l")
```


## Other distributions

Not yet written!

### Poisson distribution

### Log-normal distribution

### Response time distribution

### Beta distribution

### t distribution

### Chi-square distribution

### F distribution
